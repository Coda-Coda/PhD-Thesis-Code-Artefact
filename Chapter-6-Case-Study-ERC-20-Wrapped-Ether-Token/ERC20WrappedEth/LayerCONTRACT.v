(* WARNING: This file is generated by Edsger, the DeepSEA compiler.
            All modification will be lost when regenerating. *)
(* Module ERC20WrappedEth.LayerCONTRACT for ERC20WrappedEth.ds *)
Require Import BinPos.
Require Import DeepSpec.Runtime.
Require Import ERC20WrappedEth.EdsgerIdents.
Require Import ERC20WrappedEth.DataTypes.
Require Import ERC20WrappedEth.DataTypeOps.
Require Import ERC20WrappedEth.DataTypeProofs.
Require Import DeepSpec.lib.Monad.Monad.
Require Import DeepSpec.lib.Monad.MonadState.
Require Import DeepSpec.lib.Monad.StateMonad.
Require Import DeepSpec.lib.Monad.OptionMonad.
Require Import DeepSpec.lib.Monad.MonadZero.
Require Import DeepSpec.core.SynthesisStmt.
Require Import DeepSpec.core.SynthesisFunc.
Require Import backend.MachineModel.
Existing Instance MonadState_DS.
Existing Instance MonadZero_DS.

Section EdsgerGen.



Context {memModelOps : MemoryModelOps mem}.
Instance GlobalLayerSpec : LayerSpecClass := {
  memModelOps := memModelOps;
  GetHighData := global_abstract_data_type 
}.


Context`{global_abdata : !GlobalAbData init_global_abstract_data global_low_level_invariant}.
Definition CONTRACT_kernel_mode (abd : global_abstract_data_type) := True.
Global Arguments CONTRACT_kernel_mode / abd.

Class Layer_CONTRACT_Context_prf  := {
  (* ensuring global empty data matches those in the object definitions *)
  CONTRACT_init_ERC20WrappedEth_wrapped_eq : ERC20WrappedEth_wrapped init_global_abstract_data = (Int256Tree.empty Z32);
  CONTRACT_init_ERC20WrappedEth_allowances_eq : ERC20WrappedEth_allowances init_global_abstract_data = (Int256Tree.empty (Int256Tree.t Z32));
  CONTRACT_init_ERC20WrappedEth__totalSupply_eq : ERC20WrappedEth__totalSupply init_global_abstract_data = 0
}.
Context`{CTXT_prf : !Layer_CONTRACT_Context_prf}.

Instance CONTRACT_data_ops : CompatDataOps global_abstract_data_type := {
  empty_data := init_global_abstract_data;
  high_level_invariant d := True;
}.

Instance CONTRACT_data : CompatData global_abstract_data_type := {
empty_data_high_level_invariant := I
}.

Instance CONTRACT_overlay_spec : OverlaySpecClass := {
}.



Instance CONTRACT_underlay_spec : UnderlaySpecClass := {
  cdataOpsLow := @BuiltinBase_data_ops GlobalLayerSpec init_global_abstract_data;
  cdataLow := BuiltinBase_data;
}.


Section OBJECT_ERC20WrappedEth_DEFINITION.
  Context`{HM : !HyperMem}.

  (* Object variables *)
  Definition ERC20WrappedEth_wrapped_var := {|
    ltype_tp_marker := thash_int_HASH_address_Z32;

    ltype_ident := HighValues.Field HighValues.Global var_ERC20WrappedEth_ERC20WrappedEth_wrapped_ident;
    ltype_ghost := false;

    ltype_get := ERC20WrappedEth_wrapped;
    ltype_set := update_ERC20WrappedEth_wrapped;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.
  Definition ERC20WrappedEth_allowances_var := {|
    ltype_tp_marker := thash_hash_int_HASH_address_HASH_address_Z32;

    ltype_ident := HighValues.Field HighValues.Global var_ERC20WrappedEth_ERC20WrappedEth_allowances_ident;
    ltype_ghost := false;

    ltype_get := ERC20WrappedEth_allowances;
    ltype_set := update_ERC20WrappedEth_allowances;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.
  Definition ERC20WrappedEth__totalSupply_var := {|
    ltype_tp_marker := tint_Z32;

    ltype_ident := HighValues.Field HighValues.Global var_ERC20WrappedEth_ERC20WrappedEth__totalSupply_ident;
    ltype_ghost := false;

    ltype_get := ERC20WrappedEth__totalSupply;
    ltype_set := update_ERC20WrappedEth__totalSupply;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.

  Definition ERC20WrappedEth_constructor := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := nil;
    FC_returns := void_unit_pair;
    FC_body := (CCsequence
      (CCsequence
        CCskip
        (CCsequence
          CCskip
          (CCsequence
            (CCstore
              (LCvar ERC20WrappedEth__totalSupply_var)
              (ECconst_int256 tint_Z32 0 (Int256.repr 0)))
            CCskip)))
      CCskip)
  |}.
  Lemma ERC20WrappedEth_constructor_wf
      : synth_func_wellformed ERC20WrappedEth_constructor.
  Proof. solve_wellformed. Defined.
  Definition ERC20WrappedEth_constructor_opt : machine_env GetHighData -> DS unit  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
  in synth_func_spec_opt ERC20WrappedEth_constructor ERC20WrappedEth_constructor_wf.
  Definition ERC20WrappedEth_constructor_spec_hlist_opt args :=
    @apply_param_func ERC20WrappedEth_constructor.(FC_params) _
                      (ERC20WrappedEth_constructor_opt) args.

(* CEI stands for Checks Effects Interactions (pattern) and the definitions below are used
    to keep track of the safe situations in which a primitive can be called. See also
    CEIP_prf in Syntax.v and for the tactic definitions see Runtime.v *)
    
Lemma ERC20WrappedEth_constructor_follows_CEIP : { rsts | CEIP_function_prf (fst rsts) ERC20WrappedEth_constructor (snd rsts)}.
Proof.
  unfold ERC20WrappedEth_constructor.
  verify_checks_effects_interactions_pattern. (* If this tactic fails then it indicates that a strict version of the Checks-Effects-Interactions pattern was not followed in the function: ERC20WrappedEth_constructor. *)
Defined.

Definition ERC20WrappedEth_constructor_CEIP_color_before := fst (proj1_sig ERC20WrappedEth_constructor_follows_CEIP).
Definition ERC20WrappedEth_constructor_CEIP_color_after := snd (proj1_sig ERC20WrappedEth_constructor_follows_CEIP).

  Definition ERC20WrappedEth_constructor_prim := {|
    PRIMident := ident_ERC20WrappedEth_constructor;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := ERC20WrappedEth_constructor.(FC_params);
    PRIMret_marker := ERC20WrappedEth_constructor.(FC_returns);
    PRIMceip_color_before := ERC20WrappedEth_constructor_CEIP_color_before;
    PRIMceip_color_after := ERC20WrappedEth_constructor_CEIP_color_after;
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := ERC20WrappedEth_constructor_spec_hlist; *)
    PRIMsem_opt := ERC20WrappedEth_constructor_spec_hlist_opt
  |}.

  Lemma ERC20WrappedEth_constructor_spec_hlist_opt_eq :
    ERC20WrappedEth_constructor_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt ERC20WrappedEth_constructor ERC20WrappedEth_constructor_wf)
      args.
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]. 
     reflexivity.
  Qed.
  Definition ERC20WrappedEth_constructor_cfun :=
  Eval cbv in synth_func_func ERC20WrappedEth_constructor.

  Definition ERC20WrappedEth_constructor_cond  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_constructor ERC20WrappedEth_constructor_wf
								      me d.
  
  Lemma ERC20WrappedEth_constructor_cond_eq : forall  me d, 
    ERC20WrappedEth_constructor_cond  me d ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_constructor ERC20WrappedEth_constructor_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_constructor_obligation  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_constructor ERC20WrappedEth_constructor_wf
								      me d.
  
  Lemma ERC20WrappedEth_constructor_obligation_eq : forall  me d, 
    ERC20WrappedEth_constructor_obligation  me d ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_constructor ERC20WrappedEth_constructor_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_constructor_spec :=
  Eval cbv [sf_mem sf_return fst snd ERC20WrappedEth_constructor_opt] in
    fun  me => execStateT (ERC20WrappedEth_constructor_opt me).
  Lemma ERC20WrappedEth_constructor_spec_eq :
    ERC20WrappedEth_constructor_spec =
    fun  me => execStateT (synth_func_spec_opt ERC20WrappedEth_constructor ERC20WrappedEth_constructor_wf me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

          ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
    reflexivity.
  Qed.

Global Opaque ERC20WrappedEth_constructor_opt.

  Definition ERC20WrappedEth_totalSupply := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := nil;
    FC_returns := int_Z32_pair;
    FC_body := (CCload (LCvar ERC20WrappedEth__totalSupply_var))
  |}.
  Lemma ERC20WrappedEth_totalSupply_wf
      : synth_func_wellformed ERC20WrappedEth_totalSupply.
  Proof. solve_wellformed. Defined.
  Definition ERC20WrappedEth_totalSupply_opt : machine_env GetHighData -> DS Z32  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
  in synth_func_spec_opt ERC20WrappedEth_totalSupply ERC20WrappedEth_totalSupply_wf.
  Definition ERC20WrappedEth_totalSupply_spec_hlist_opt args :=
    @apply_param_func ERC20WrappedEth_totalSupply.(FC_params) _
                      (ERC20WrappedEth_totalSupply_opt) args.

(* CEI stands for Checks Effects Interactions (pattern) and the definitions below are used
    to keep track of the safe situations in which a primitive can be called. See also
    CEIP_prf in Syntax.v and for the tactic definitions see Runtime.v *)
    
Lemma ERC20WrappedEth_totalSupply_follows_CEIP : { rsts | CEIP_function_prf (fst rsts) ERC20WrappedEth_totalSupply (snd rsts)}.
Proof.
  unfold ERC20WrappedEth_totalSupply.
  verify_checks_effects_interactions_pattern. (* If this tactic fails then it indicates that a strict version of the Checks-Effects-Interactions pattern was not followed in the function: ERC20WrappedEth_totalSupply. *)
Defined.

Definition ERC20WrappedEth_totalSupply_CEIP_color_before := fst (proj1_sig ERC20WrappedEth_totalSupply_follows_CEIP).
Definition ERC20WrappedEth_totalSupply_CEIP_color_after := snd (proj1_sig ERC20WrappedEth_totalSupply_follows_CEIP).

  Definition ERC20WrappedEth_totalSupply_prim := {|
    PRIMident := ident_ERC20WrappedEth_totalSupply;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := true;
    PRIMargt_marker := ERC20WrappedEth_totalSupply.(FC_params);
    PRIMret_marker := ERC20WrappedEth_totalSupply.(FC_returns);
    PRIMceip_color_before := ERC20WrappedEth_totalSupply_CEIP_color_before;
    PRIMceip_color_after := ERC20WrappedEth_totalSupply_CEIP_color_after;
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := ERC20WrappedEth_totalSupply_spec_hlist; *)
    PRIMsem_opt := ERC20WrappedEth_totalSupply_spec_hlist_opt
  |}.

  Lemma ERC20WrappedEth_totalSupply_spec_hlist_opt_eq :
    ERC20WrappedEth_totalSupply_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt ERC20WrappedEth_totalSupply ERC20WrappedEth_totalSupply_wf)
      args.
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]. 
     reflexivity.
  Qed.
  Definition ERC20WrappedEth_totalSupply_cfun :=
  Eval cbv in synth_func_func ERC20WrappedEth_totalSupply.

  Definition ERC20WrappedEth_totalSupply_cond  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_totalSupply ERC20WrappedEth_totalSupply_wf
								      me d.
  
  Lemma ERC20WrappedEth_totalSupply_cond_eq : forall  me d, 
    ERC20WrappedEth_totalSupply_cond  me d ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_totalSupply ERC20WrappedEth_totalSupply_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_totalSupply_obligation  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_totalSupply ERC20WrappedEth_totalSupply_wf
								      me d.
  
  Lemma ERC20WrappedEth_totalSupply_obligation_eq : forall  me d, 
    ERC20WrappedEth_totalSupply_obligation  me d ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_totalSupply ERC20WrappedEth_totalSupply_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_totalSupply_spec :=
  Eval cbv [sf_mem sf_return fst snd ERC20WrappedEth_totalSupply_opt] in
    fun  me => evalStateT (ERC20WrappedEth_totalSupply_opt me).
  Lemma ERC20WrappedEth_totalSupply_spec_eq :
    ERC20WrappedEth_totalSupply_spec =
    fun  me => evalStateT (synth_func_spec_opt ERC20WrappedEth_totalSupply ERC20WrappedEth_totalSupply_wf me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

          ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
    reflexivity.
  Qed.

Global Opaque ERC20WrappedEth_totalSupply_opt.

  Definition ERC20WrappedEth_balanceOf := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := (cons (* _owner : *) int_U_pair nil);
    FC_returns := int_Z32_pair;
    FC_body := (CCload (LChash tint_Z32
      (LCvar ERC20WrappedEth_wrapped_var)
      (ECtempvar tint_U 11%positive (* _owner *))))
  |}.
  Lemma ERC20WrappedEth_balanceOf_wf
      : synth_func_wellformed ERC20WrappedEth_balanceOf.
  Proof. solve_wellformed. Defined.
  Definition ERC20WrappedEth_balanceOf_opt :int256 ->  machine_env GetHighData -> DS Z32  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
  in synth_func_spec_opt ERC20WrappedEth_balanceOf ERC20WrappedEth_balanceOf_wf.
  Definition ERC20WrappedEth_balanceOf_spec_hlist_opt args :=
    @apply_param_func ERC20WrappedEth_balanceOf.(FC_params) _
                      (ERC20WrappedEth_balanceOf_opt) args.

(* CEI stands for Checks Effects Interactions (pattern) and the definitions below are used
    to keep track of the safe situations in which a primitive can be called. See also
    CEIP_prf in Syntax.v and for the tactic definitions see Runtime.v *)
    
Lemma ERC20WrappedEth_balanceOf_follows_CEIP : { rsts | CEIP_function_prf (fst rsts) ERC20WrappedEth_balanceOf (snd rsts)}.
Proof.
  unfold ERC20WrappedEth_balanceOf.
  verify_checks_effects_interactions_pattern. (* If this tactic fails then it indicates that a strict version of the Checks-Effects-Interactions pattern was not followed in the function: ERC20WrappedEth_balanceOf. *)
Defined.

Definition ERC20WrappedEth_balanceOf_CEIP_color_before := fst (proj1_sig ERC20WrappedEth_balanceOf_follows_CEIP).
Definition ERC20WrappedEth_balanceOf_CEIP_color_after := snd (proj1_sig ERC20WrappedEth_balanceOf_follows_CEIP).

  Definition ERC20WrappedEth_balanceOf_prim := {|
    PRIMident := ident_ERC20WrappedEth_balanceOf;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := true;
    PRIMargt_marker := ERC20WrappedEth_balanceOf.(FC_params);
    PRIMret_marker := ERC20WrappedEth_balanceOf.(FC_returns);
    PRIMceip_color_before := ERC20WrappedEth_balanceOf_CEIP_color_before;
    PRIMceip_color_after := ERC20WrappedEth_balanceOf_CEIP_color_after;
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := ERC20WrappedEth_balanceOf_spec_hlist; *)
    PRIMsem_opt := ERC20WrappedEth_balanceOf_spec_hlist_opt
  |}.

  Lemma ERC20WrappedEth_balanceOf_spec_hlist_opt_eq :
    ERC20WrappedEth_balanceOf_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt ERC20WrappedEth_balanceOf ERC20WrappedEth_balanceOf_wf)
      args.
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]. 
     reflexivity.
  Qed.
  Definition ERC20WrappedEth_balanceOf_cfun :=
  Eval cbv in synth_func_func ERC20WrappedEth_balanceOf.

  Definition ERC20WrappedEth_balanceOf_cond  a0 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_balanceOf ERC20WrappedEth_balanceOf_wf
								      a0 me d.
  
  Lemma ERC20WrappedEth_balanceOf_cond_eq : forall  a0 me d, 
    ERC20WrappedEth_balanceOf_cond  a0 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_balanceOf ERC20WrappedEth_balanceOf_wf  a0 me d.
    Proof.
      intros  a0 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_balanceOf_obligation  a0 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_balanceOf ERC20WrappedEth_balanceOf_wf
								      a0 me d.
  
  Lemma ERC20WrappedEth_balanceOf_obligation_eq : forall  a0 me d, 
    ERC20WrappedEth_balanceOf_obligation  a0 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_balanceOf ERC20WrappedEth_balanceOf_wf  a0 me d.
    Proof.
      intros  a0 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_balanceOf_spec :=
  Eval cbv [sf_mem sf_return fst snd ERC20WrappedEth_balanceOf_opt] in
    fun  a0 me => evalStateT (ERC20WrappedEth_balanceOf_opt a0 me).
  Lemma ERC20WrappedEth_balanceOf_spec_eq :
    ERC20WrappedEth_balanceOf_spec =
    fun  a0 me => evalStateT (synth_func_spec_opt ERC20WrappedEth_balanceOf ERC20WrappedEth_balanceOf_wf a0 me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

          ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
    reflexivity.
  Qed.

Global Opaque ERC20WrappedEth_balanceOf_opt.

  Definition ERC20WrappedEth_transfer := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := (cons (* _to : *) int_U_pair (cons (* _value : *) int_Z32_pair nil));
    FC_returns := int_bool_pair;
    FC_body := (CCsequence
      (CCassert (CCyield (ECbinop tint_bool Oge
        (ECtempvar tint_Z32 12%positive (* _value *))
        (ECconst_int256 tint_Z32 0 (Int256.repr 0)))))
      (CCsequence
        (CCassert (CCyield (ECbinop tint_bool One
          (@ECbuiltin0 _ _  _ builtin0_caller_impl)
          (@ECbuiltin0 _ _  _ builtin0_address_impl))))
        (CCsequence
          (CCassert (CCyield (ECbinop tint_bool One
            (@ECbuiltin0 _ _  _ builtin0_caller_impl)
            (ECtempvar tint_U 11%positive (* _to *)))))
          (CCsequence
            (CCassert (CCyield (ECbinop tint_bool Oeq
              (@ECbuiltin0 _ _  _ builtin0_callvalue_impl)
              (ECconst_int256 tint_Z32 0 (Int256.repr 0)))))
            (CClet (* wrapped_amount_from := *) 17%positive
              (CCload (LChash tint_Z32
                (LCvar ERC20WrappedEth_wrapped_var)
                (@ECbuiltin0 _ _  _ builtin0_caller_impl)))
              (CClet (* wrapped_amount_to := *) 18%positive
                (CCload (LChash tint_Z32
                  (LCvar ERC20WrappedEth_wrapped_var)
                  (ECtempvar tint_U 11%positive (* _to *))))
                (CCsequence
                  (CCassert (CCyield (ECbinop tint_bool Oge
                    (ECtempvar tint_Z32 17%positive (* wrapped_amount_from *))
                    (ECtempvar tint_Z32 12%positive (* _value *)))))
                  (CCsequence
                    (CCstore
                      (LChash tint_Z32
                        (LCvar ERC20WrappedEth_wrapped_var)
                        (ECtempvar tint_U 11%positive (* _to *)))
                      (ECbinop tint_Z32 Oadd
                        (ECtempvar tint_Z32 18%positive (* wrapped_amount_to *))
                        (ECtempvar tint_Z32 12%positive (* _value *))))
                    (CCsequence
                      (CCstore
                        (LChash tint_Z32
                          (LCvar ERC20WrappedEth_wrapped_var)
                          (@ECbuiltin0 _ _  _ builtin0_caller_impl))
                        (ECbinop tint_Z32 Osub
                          (ECtempvar tint_Z32 17%positive (* wrapped_amount_from *))
                          (ECtempvar tint_Z32 12%positive (* _value *))))
                      (CCsequence
                        CCskip
                        (CCyield (ECconst_int256 tint_bool true Int256.one))))))))))))
  |}.
  Lemma ERC20WrappedEth_transfer_wf
      : synth_func_wellformed ERC20WrappedEth_transfer.
  Proof. solve_wellformed. Defined.
  Definition ERC20WrappedEth_transfer_opt :int256 -> Z32 ->  machine_env GetHighData -> DS bool  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
  in synth_func_spec_opt ERC20WrappedEth_transfer ERC20WrappedEth_transfer_wf.
  Definition ERC20WrappedEth_transfer_spec_hlist_opt args :=
    @apply_param_func ERC20WrappedEth_transfer.(FC_params) _
                      (ERC20WrappedEth_transfer_opt) args.

(* CEI stands for Checks Effects Interactions (pattern) and the definitions below are used
    to keep track of the safe situations in which a primitive can be called. See also
    CEIP_prf in Syntax.v and for the tactic definitions see Runtime.v *)
    
Lemma ERC20WrappedEth_transfer_follows_CEIP : { rsts | CEIP_function_prf (fst rsts) ERC20WrappedEth_transfer (snd rsts)}.
Proof.
  unfold ERC20WrappedEth_transfer.
  verify_checks_effects_interactions_pattern. (* If this tactic fails then it indicates that a strict version of the Checks-Effects-Interactions pattern was not followed in the function: ERC20WrappedEth_transfer. *)
Defined.

Definition ERC20WrappedEth_transfer_CEIP_color_before := fst (proj1_sig ERC20WrappedEth_transfer_follows_CEIP).
Definition ERC20WrappedEth_transfer_CEIP_color_after := snd (proj1_sig ERC20WrappedEth_transfer_follows_CEIP).

  Definition ERC20WrappedEth_transfer_prim := {|
    PRIMident := ident_ERC20WrappedEth_transfer;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := ERC20WrappedEth_transfer.(FC_params);
    PRIMret_marker := ERC20WrappedEth_transfer.(FC_returns);
    PRIMceip_color_before := ERC20WrappedEth_transfer_CEIP_color_before;
    PRIMceip_color_after := ERC20WrappedEth_transfer_CEIP_color_after;
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := ERC20WrappedEth_transfer_spec_hlist; *)
    PRIMsem_opt := ERC20WrappedEth_transfer_spec_hlist_opt
  |}.

  Lemma ERC20WrappedEth_transfer_spec_hlist_opt_eq :
    ERC20WrappedEth_transfer_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt ERC20WrappedEth_transfer ERC20WrappedEth_transfer_wf)
      args.
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]. 
     reflexivity.
  Qed.
  Definition ERC20WrappedEth_transfer_cfun :=
  Eval cbv in synth_func_func ERC20WrappedEth_transfer.

  Definition ERC20WrappedEth_transfer_cond  a0 a1 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_transfer ERC20WrappedEth_transfer_wf
								      a0 a1 me d.
  
  Lemma ERC20WrappedEth_transfer_cond_eq : forall  a0 a1 me d, 
    ERC20WrappedEth_transfer_cond  a0 a1 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_transfer ERC20WrappedEth_transfer_wf  a0 a1 me d.
    Proof.
      intros  a0 a1 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_transfer_obligation  a0 a1 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_transfer ERC20WrappedEth_transfer_wf
								      a0 a1 me d.
  
  Lemma ERC20WrappedEth_transfer_obligation_eq : forall  a0 a1 me d, 
    ERC20WrappedEth_transfer_obligation  a0 a1 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_transfer ERC20WrappedEth_transfer_wf  a0 a1 me d.
    Proof.
      intros  a0 a1 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_transfer_spec :=
  Eval cbv [sf_mem sf_return fst snd ERC20WrappedEth_transfer_opt] in
    fun  a0 a1 me => runStateT (ERC20WrappedEth_transfer_opt a0 a1 me).
  Lemma ERC20WrappedEth_transfer_spec_eq :
    ERC20WrappedEth_transfer_spec =
    fun  a0 a1 me => runStateT (synth_func_spec_opt ERC20WrappedEth_transfer ERC20WrappedEth_transfer_wf a0 a1 me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

          ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
    reflexivity.
  Qed.

Global Opaque ERC20WrappedEth_transfer_opt.

  Definition ERC20WrappedEth_transferFrom := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := (cons (* _from : *) int_U_pair (cons (* _to : *) int_U_pair (cons (* _value : *) int_Z32_pair nil)));
    FC_returns := int_bool_pair;
    FC_body := (CCsequence
      (CCassert (CCyield (ECbinop tint_bool Oge
        (ECtempvar tint_Z32 13%positive (* _value *))
        (ECconst_int256 tint_Z32 0 (Int256.repr 0)))))
      (CCsequence
        (CCassert (CCyield (ECbinop tint_bool One
          (ECtempvar tint_U 11%positive (* _from *))
          (@ECbuiltin0 _ _  _ builtin0_address_impl))))
        (CCsequence
          (CCassert (CCyield (ECbinop tint_bool One
            (ECtempvar tint_U 11%positive (* _from *))
            (ECtempvar tint_U 12%positive (* _to *)))))
          (CCsequence
            (CCassert (CCyield (ECbinop tint_bool Oeq
              (@ECbuiltin0 _ _  _ builtin0_callvalue_impl)
              (ECconst_int256 tint_Z32 0 (Int256.repr 0)))))
            (CClet (* approved_amount := *) 18%positive
              (CCload (LChash tint_Z32
                (LChash thash_int_HASH_address_Z32
                  (LCvar ERC20WrappedEth_allowances_var)
                  (@ECbuiltin0 _ _  _ builtin0_caller_impl))
                (ECtempvar tint_U 11%positive (* _from *))))
              (CCsequence
                (CCassert (CCyield (ECbinop tint_bool Oge
                  (ECtempvar tint_Z32 18%positive (* approved_amount *))
                  (ECtempvar tint_Z32 13%positive (* _value *)))))
                (CCsequence
                  (CCstore
                    (LChash tint_Z32
                      (LChash thash_int_HASH_address_Z32
                        (LCvar ERC20WrappedEth_allowances_var)
                        (@ECbuiltin0 _ _  _ builtin0_caller_impl))
                      (ECtempvar tint_U 11%positive (* _from *)))
                    (ECbinop tint_Z32 Osub
                      (ECtempvar tint_Z32 18%positive (* approved_amount *))
                      (ECtempvar tint_Z32 13%positive (* _value *))))
                  (CClet (* wrapped_amount_from := *) 20%positive
                    (CCload (LChash tint_Z32
                      (LCvar ERC20WrappedEth_wrapped_var)
                      (ECtempvar tint_U 11%positive (* _from *))))
                    (CClet (* wrapped_amount_to := *) 21%positive
                      (CCload (LChash tint_Z32
                        (LCvar ERC20WrappedEth_wrapped_var)
                        (ECtempvar tint_U 12%positive (* _to *))))
                      (CCsequence
                        (CCassert (CCyield (ECbinop tint_bool Oge
                          (ECtempvar tint_Z32 20%positive (* wrapped_amount_from *))
                          (ECtempvar tint_Z32 13%positive (* _value *)))))
                        (CCsequence
                          (CCstore
                            (LChash tint_Z32
                              (LCvar ERC20WrappedEth_wrapped_var)
                              (ECtempvar tint_U 12%positive (* _to *)))
                            (ECbinop tint_Z32 Oadd
                              (ECtempvar tint_Z32 21%positive (* wrapped_amount_to *))
                              (ECtempvar tint_Z32 13%positive (* _value *))))
                          (CCsequence
                            (CCstore
                              (LChash tint_Z32
                                (LCvar ERC20WrappedEth_wrapped_var)
                                (ECtempvar tint_U 11%positive (* _from *)))
                              (ECbinop tint_Z32 Osub
                                (ECtempvar tint_Z32 20%positive (* wrapped_amount_from *))
                                (ECtempvar tint_Z32 13%positive (* _value *))))
                            (CCsequence
                              CCskip
                              (CCyield (ECconst_int256 tint_bool true Int256.one)))))))))))))))
  |}.
  Lemma ERC20WrappedEth_transferFrom_wf
      : synth_func_wellformed ERC20WrappedEth_transferFrom.
  Proof. solve_wellformed. Defined.
  Definition ERC20WrappedEth_transferFrom_opt :int256 -> int256 -> Z32 ->  machine_env GetHighData -> DS bool  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
  in synth_func_spec_opt ERC20WrappedEth_transferFrom ERC20WrappedEth_transferFrom_wf.
  Definition ERC20WrappedEth_transferFrom_spec_hlist_opt args :=
    @apply_param_func ERC20WrappedEth_transferFrom.(FC_params) _
                      (ERC20WrappedEth_transferFrom_opt) args.

(* CEI stands for Checks Effects Interactions (pattern) and the definitions below are used
    to keep track of the safe situations in which a primitive can be called. See also
    CEIP_prf in Syntax.v and for the tactic definitions see Runtime.v *)
    
Lemma ERC20WrappedEth_transferFrom_follows_CEIP : { rsts | CEIP_function_prf (fst rsts) ERC20WrappedEth_transferFrom (snd rsts)}.
Proof.
  unfold ERC20WrappedEth_transferFrom.
  verify_checks_effects_interactions_pattern. (* If this tactic fails then it indicates that a strict version of the Checks-Effects-Interactions pattern was not followed in the function: ERC20WrappedEth_transferFrom. *)
Defined.

Definition ERC20WrappedEth_transferFrom_CEIP_color_before := fst (proj1_sig ERC20WrappedEth_transferFrom_follows_CEIP).
Definition ERC20WrappedEth_transferFrom_CEIP_color_after := snd (proj1_sig ERC20WrappedEth_transferFrom_follows_CEIP).

  Definition ERC20WrappedEth_transferFrom_prim := {|
    PRIMident := ident_ERC20WrappedEth_transferFrom;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := ERC20WrappedEth_transferFrom.(FC_params);
    PRIMret_marker := ERC20WrappedEth_transferFrom.(FC_returns);
    PRIMceip_color_before := ERC20WrappedEth_transferFrom_CEIP_color_before;
    PRIMceip_color_after := ERC20WrappedEth_transferFrom_CEIP_color_after;
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := ERC20WrappedEth_transferFrom_spec_hlist; *)
    PRIMsem_opt := ERC20WrappedEth_transferFrom_spec_hlist_opt
  |}.

  Lemma ERC20WrappedEth_transferFrom_spec_hlist_opt_eq :
    ERC20WrappedEth_transferFrom_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt ERC20WrappedEth_transferFrom ERC20WrappedEth_transferFrom_wf)
      args.
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]. 
     reflexivity.
  Qed.
  Definition ERC20WrappedEth_transferFrom_cfun :=
  Eval cbv in synth_func_func ERC20WrappedEth_transferFrom.

  Definition ERC20WrappedEth_transferFrom_cond  a0 a1 a2 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    ht_ft_cond a2 -> ht_valid_ft_cond a2 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_transferFrom ERC20WrappedEth_transferFrom_wf
								      a0 a1 a2 me d.
  
  Lemma ERC20WrappedEth_transferFrom_cond_eq : forall  a0 a1 a2 me d, 
    ERC20WrappedEth_transferFrom_cond  a0 a1 a2 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    ht_ft_cond a2 -> ht_valid_ft_cond a2 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_transferFrom ERC20WrappedEth_transferFrom_wf  a0 a1 a2 me d.
    Proof.
      intros  a0 a1 a2 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_transferFrom_obligation  a0 a1 a2 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    ht_ft_cond a2 -> ht_valid_ft_cond a2 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_transferFrom ERC20WrappedEth_transferFrom_wf
								      a0 a1 a2 me d.
  
  Lemma ERC20WrappedEth_transferFrom_obligation_eq : forall  a0 a1 a2 me d, 
    ERC20WrappedEth_transferFrom_obligation  a0 a1 a2 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    ht_ft_cond a2 -> ht_valid_ft_cond a2 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_transferFrom ERC20WrappedEth_transferFrom_wf  a0 a1 a2 me d.
    Proof.
      intros  a0 a1 a2 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_transferFrom_spec :=
  Eval cbv [sf_mem sf_return fst snd ERC20WrappedEth_transferFrom_opt] in
    fun  a0 a1 a2 me => runStateT (ERC20WrappedEth_transferFrom_opt a0 a1 a2 me).
  Lemma ERC20WrappedEth_transferFrom_spec_eq :
    ERC20WrappedEth_transferFrom_spec =
    fun  a0 a1 a2 me => runStateT (synth_func_spec_opt ERC20WrappedEth_transferFrom ERC20WrappedEth_transferFrom_wf a0 a1 a2 me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

          ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
    reflexivity.
  Qed.

Global Opaque ERC20WrappedEth_transferFrom_opt.

  Definition ERC20WrappedEth_allowance := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := (cons (* _owner : *) int_U_pair (cons (* _spender : *) int_U_pair nil));
    FC_returns := int_Z32_pair;
    FC_body := (CCload (LChash tint_Z32
      (LChash thash_int_HASH_address_Z32
        (LCvar ERC20WrappedEth_allowances_var)
        (ECtempvar tint_U 11%positive (* _owner *)))
      (ECtempvar tint_U 12%positive (* _spender *))))
  |}.
  Lemma ERC20WrappedEth_allowance_wf
      : synth_func_wellformed ERC20WrappedEth_allowance.
  Proof. solve_wellformed. Defined.
  Definition ERC20WrappedEth_allowance_opt :int256 -> int256 ->  machine_env GetHighData -> DS Z32  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
  in synth_func_spec_opt ERC20WrappedEth_allowance ERC20WrappedEth_allowance_wf.
  Definition ERC20WrappedEth_allowance_spec_hlist_opt args :=
    @apply_param_func ERC20WrappedEth_allowance.(FC_params) _
                      (ERC20WrappedEth_allowance_opt) args.

(* CEI stands for Checks Effects Interactions (pattern) and the definitions below are used
    to keep track of the safe situations in which a primitive can be called. See also
    CEIP_prf in Syntax.v and for the tactic definitions see Runtime.v *)
    
Lemma ERC20WrappedEth_allowance_follows_CEIP : { rsts | CEIP_function_prf (fst rsts) ERC20WrappedEth_allowance (snd rsts)}.
Proof.
  unfold ERC20WrappedEth_allowance.
  verify_checks_effects_interactions_pattern. (* If this tactic fails then it indicates that a strict version of the Checks-Effects-Interactions pattern was not followed in the function: ERC20WrappedEth_allowance. *)
Defined.

Definition ERC20WrappedEth_allowance_CEIP_color_before := fst (proj1_sig ERC20WrappedEth_allowance_follows_CEIP).
Definition ERC20WrappedEth_allowance_CEIP_color_after := snd (proj1_sig ERC20WrappedEth_allowance_follows_CEIP).

  Definition ERC20WrappedEth_allowance_prim := {|
    PRIMident := ident_ERC20WrappedEth_allowance;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := true;
    PRIMargt_marker := ERC20WrappedEth_allowance.(FC_params);
    PRIMret_marker := ERC20WrappedEth_allowance.(FC_returns);
    PRIMceip_color_before := ERC20WrappedEth_allowance_CEIP_color_before;
    PRIMceip_color_after := ERC20WrappedEth_allowance_CEIP_color_after;
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := ERC20WrappedEth_allowance_spec_hlist; *)
    PRIMsem_opt := ERC20WrappedEth_allowance_spec_hlist_opt
  |}.

  Lemma ERC20WrappedEth_allowance_spec_hlist_opt_eq :
    ERC20WrappedEth_allowance_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt ERC20WrappedEth_allowance ERC20WrappedEth_allowance_wf)
      args.
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]. 
     reflexivity.
  Qed.
  Definition ERC20WrappedEth_allowance_cfun :=
  Eval cbv in synth_func_func ERC20WrappedEth_allowance.

  Definition ERC20WrappedEth_allowance_cond  a0 a1 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_allowance ERC20WrappedEth_allowance_wf
								      a0 a1 me d.
  
  Lemma ERC20WrappedEth_allowance_cond_eq : forall  a0 a1 me d, 
    ERC20WrappedEth_allowance_cond  a0 a1 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_allowance ERC20WrappedEth_allowance_wf  a0 a1 me d.
    Proof.
      intros  a0 a1 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_allowance_obligation  a0 a1 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_allowance ERC20WrappedEth_allowance_wf
								      a0 a1 me d.
  
  Lemma ERC20WrappedEth_allowance_obligation_eq : forall  a0 a1 me d, 
    ERC20WrappedEth_allowance_obligation  a0 a1 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_allowance ERC20WrappedEth_allowance_wf  a0 a1 me d.
    Proof.
      intros  a0 a1 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_allowance_spec :=
  Eval cbv [sf_mem sf_return fst snd ERC20WrappedEth_allowance_opt] in
    fun  a0 a1 me => evalStateT (ERC20WrappedEth_allowance_opt a0 a1 me).
  Lemma ERC20WrappedEth_allowance_spec_eq :
    ERC20WrappedEth_allowance_spec =
    fun  a0 a1 me => evalStateT (synth_func_spec_opt ERC20WrappedEth_allowance ERC20WrappedEth_allowance_wf a0 a1 me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

          ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
    reflexivity.
  Qed.

Global Opaque ERC20WrappedEth_allowance_opt.

  Definition ERC20WrappedEth_approve := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := (cons (* _spender : *) int_U_pair (cons (* _value : *) int_Z32_pair nil));
    FC_returns := int_bool_pair;
    FC_body := (CCsequence
      (CCassert (CCyield (ECbinop tint_bool Oge
        (ECtempvar tint_Z32 12%positive (* _value *))
        (ECconst_int256 tint_Z32 0 (Int256.repr 0)))))
      (CCsequence
        (CCstore
          (LChash tint_Z32
            (LChash thash_int_HASH_address_Z32
              (LCvar ERC20WrappedEth_allowances_var)
              (@ECbuiltin0 _ _  _ builtin0_caller_impl))
            (ECtempvar tint_U 11%positive (* _spender *)))
          (ECtempvar tint_Z32 12%positive (* _value *)))
        (CCsequence
          CCskip
          (CCyield (ECconst_int256 tint_bool true Int256.one)))))
  |}.
  Lemma ERC20WrappedEth_approve_wf
      : synth_func_wellformed ERC20WrappedEth_approve.
  Proof. solve_wellformed. Defined.
  Definition ERC20WrappedEth_approve_opt :int256 -> Z32 ->  machine_env GetHighData -> DS bool  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
  in synth_func_spec_opt ERC20WrappedEth_approve ERC20WrappedEth_approve_wf.
  Definition ERC20WrappedEth_approve_spec_hlist_opt args :=
    @apply_param_func ERC20WrappedEth_approve.(FC_params) _
                      (ERC20WrappedEth_approve_opt) args.

(* CEI stands for Checks Effects Interactions (pattern) and the definitions below are used
    to keep track of the safe situations in which a primitive can be called. See also
    CEIP_prf in Syntax.v and for the tactic definitions see Runtime.v *)
    
Lemma ERC20WrappedEth_approve_follows_CEIP : { rsts | CEIP_function_prf (fst rsts) ERC20WrappedEth_approve (snd rsts)}.
Proof.
  unfold ERC20WrappedEth_approve.
  verify_checks_effects_interactions_pattern. (* If this tactic fails then it indicates that a strict version of the Checks-Effects-Interactions pattern was not followed in the function: ERC20WrappedEth_approve. *)
Defined.

Definition ERC20WrappedEth_approve_CEIP_color_before := fst (proj1_sig ERC20WrappedEth_approve_follows_CEIP).
Definition ERC20WrappedEth_approve_CEIP_color_after := snd (proj1_sig ERC20WrappedEth_approve_follows_CEIP).

  Definition ERC20WrappedEth_approve_prim := {|
    PRIMident := ident_ERC20WrappedEth_approve;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := ERC20WrappedEth_approve.(FC_params);
    PRIMret_marker := ERC20WrappedEth_approve.(FC_returns);
    PRIMceip_color_before := ERC20WrappedEth_approve_CEIP_color_before;
    PRIMceip_color_after := ERC20WrappedEth_approve_CEIP_color_after;
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := ERC20WrappedEth_approve_spec_hlist; *)
    PRIMsem_opt := ERC20WrappedEth_approve_spec_hlist_opt
  |}.

  Lemma ERC20WrappedEth_approve_spec_hlist_opt_eq :
    ERC20WrappedEth_approve_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt ERC20WrappedEth_approve ERC20WrappedEth_approve_wf)
      args.
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]. 
     reflexivity.
  Qed.
  Definition ERC20WrappedEth_approve_cfun :=
  Eval cbv in synth_func_func ERC20WrappedEth_approve.

  Definition ERC20WrappedEth_approve_cond  a0 a1 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_approve ERC20WrappedEth_approve_wf
								      a0 a1 me d.
  
  Lemma ERC20WrappedEth_approve_cond_eq : forall  a0 a1 me d, 
    ERC20WrappedEth_approve_cond  a0 a1 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_approve ERC20WrappedEth_approve_wf  a0 a1 me d.
    Proof.
      intros  a0 a1 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_approve_obligation  a0 a1 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_approve ERC20WrappedEth_approve_wf
								      a0 a1 me d.
  
  Lemma ERC20WrappedEth_approve_obligation_eq : forall  a0 a1 me d, 
    ERC20WrappedEth_approve_obligation  a0 a1 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_approve ERC20WrappedEth_approve_wf  a0 a1 me d.
    Proof.
      intros  a0 a1 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_approve_spec :=
  Eval cbv [sf_mem sf_return fst snd ERC20WrappedEth_approve_opt] in
    fun  a0 a1 me => runStateT (ERC20WrappedEth_approve_opt a0 a1 me).
  Lemma ERC20WrappedEth_approve_spec_eq :
    ERC20WrappedEth_approve_spec =
    fun  a0 a1 me => runStateT (synth_func_spec_opt ERC20WrappedEth_approve ERC20WrappedEth_approve_wf a0 a1 me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

          ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
    reflexivity.
  Qed.

Global Opaque ERC20WrappedEth_approve_opt.

  Definition ERC20WrappedEth_approveSafely := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := (cons (* _spender : *) int_U_pair (cons (* _currentValue : *) int_Z32_pair (cons (* _value : *) int_Z32_pair nil)));
    FC_returns := int_bool_pair;
    FC_body := (CCsequence
      (CCassert (CCyield (ECbinop tint_bool Oge
        (ECtempvar tint_Z32 13%positive (* _value *))
        (ECconst_int256 tint_Z32 0 (Int256.repr 0)))))
      (CClet (* actualCurrentValue := *) 15%positive
        (CCload (LChash tint_Z32
          (LChash thash_int_HASH_address_Z32
            (LCvar ERC20WrappedEth_allowances_var)
            (@ECbuiltin0 _ _  _ builtin0_caller_impl))
          (ECtempvar tint_U 11%positive (* _spender *))))
        (CCifthenelse (ECbinop tint_bool Oeq
            (ECtempvar tint_Z32 12%positive (* _currentValue *))
            (ECtempvar tint_Z32 15%positive (* actualCurrentValue *)))
          (CCsequence
            (CCstore
              (LChash tint_Z32
                (LChash thash_int_HASH_address_Z32
                  (LCvar ERC20WrappedEth_allowances_var)
                  (@ECbuiltin0 _ _  _ builtin0_caller_impl))
                (ECtempvar tint_U 11%positive (* _spender *)))
              (ECtempvar tint_Z32 13%positive (* _value *)))
            (CCsequence
              CCskip
              (CCyield (ECconst_int256 tint_bool true Int256.one))))
          (CCyield (ECconst_int256 tint_bool false Int256.zero)))))
  |}.
  Lemma ERC20WrappedEth_approveSafely_wf
      : synth_func_wellformed ERC20WrappedEth_approveSafely.
  Proof. solve_wellformed. Defined.
  Definition ERC20WrappedEth_approveSafely_opt :int256 -> Z32 -> Z32 ->  machine_env GetHighData -> DS bool  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
  in synth_func_spec_opt ERC20WrappedEth_approveSafely ERC20WrappedEth_approveSafely_wf.
  Definition ERC20WrappedEth_approveSafely_spec_hlist_opt args :=
    @apply_param_func ERC20WrappedEth_approveSafely.(FC_params) _
                      (ERC20WrappedEth_approveSafely_opt) args.

(* CEI stands for Checks Effects Interactions (pattern) and the definitions below are used
    to keep track of the safe situations in which a primitive can be called. See also
    CEIP_prf in Syntax.v and for the tactic definitions see Runtime.v *)
    
Lemma ERC20WrappedEth_approveSafely_follows_CEIP : { rsts | CEIP_function_prf (fst rsts) ERC20WrappedEth_approveSafely (snd rsts)}.
Proof.
  unfold ERC20WrappedEth_approveSafely.
  verify_checks_effects_interactions_pattern. (* If this tactic fails then it indicates that a strict version of the Checks-Effects-Interactions pattern was not followed in the function: ERC20WrappedEth_approveSafely. *)
Defined.

Definition ERC20WrappedEth_approveSafely_CEIP_color_before := fst (proj1_sig ERC20WrappedEth_approveSafely_follows_CEIP).
Definition ERC20WrappedEth_approveSafely_CEIP_color_after := snd (proj1_sig ERC20WrappedEth_approveSafely_follows_CEIP).

  Definition ERC20WrappedEth_approveSafely_prim := {|
    PRIMident := ident_ERC20WrappedEth_approveSafely;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := ERC20WrappedEth_approveSafely.(FC_params);
    PRIMret_marker := ERC20WrappedEth_approveSafely.(FC_returns);
    PRIMceip_color_before := ERC20WrappedEth_approveSafely_CEIP_color_before;
    PRIMceip_color_after := ERC20WrappedEth_approveSafely_CEIP_color_after;
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := ERC20WrappedEth_approveSafely_spec_hlist; *)
    PRIMsem_opt := ERC20WrappedEth_approveSafely_spec_hlist_opt
  |}.

  Lemma ERC20WrappedEth_approveSafely_spec_hlist_opt_eq :
    ERC20WrappedEth_approveSafely_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt ERC20WrappedEth_approveSafely ERC20WrappedEth_approveSafely_wf)
      args.
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]. 
     reflexivity.
  Qed.
  Definition ERC20WrappedEth_approveSafely_cfun :=
  Eval cbv in synth_func_func ERC20WrappedEth_approveSafely.

  Definition ERC20WrappedEth_approveSafely_cond  a0 a1 a2 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    ht_ft_cond a2 -> ht_valid_ft_cond a2 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_approveSafely ERC20WrappedEth_approveSafely_wf
								      a0 a1 a2 me d.
  
  Lemma ERC20WrappedEth_approveSafely_cond_eq : forall  a0 a1 a2 me d, 
    ERC20WrappedEth_approveSafely_cond  a0 a1 a2 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    ht_ft_cond a2 -> ht_valid_ft_cond a2 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_approveSafely ERC20WrappedEth_approveSafely_wf  a0 a1 a2 me d.
    Proof.
      intros  a0 a1 a2 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_approveSafely_obligation  a0 a1 a2 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    ht_ft_cond a2 -> ht_valid_ft_cond a2 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_approveSafely ERC20WrappedEth_approveSafely_wf
								      a0 a1 a2 me d.
  
  Lemma ERC20WrappedEth_approveSafely_obligation_eq : forall  a0 a1 a2 me d, 
    ERC20WrappedEth_approveSafely_obligation  a0 a1 a2 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    ht_ft_cond a2 -> ht_valid_ft_cond a2 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_approveSafely ERC20WrappedEth_approveSafely_wf  a0 a1 a2 me d.
    Proof.
      intros  a0 a1 a2 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_approveSafely_spec :=
  Eval cbv [sf_mem sf_return fst snd ERC20WrappedEth_approveSafely_opt] in
    fun  a0 a1 a2 me => runStateT (ERC20WrappedEth_approveSafely_opt a0 a1 a2 me).
  Lemma ERC20WrappedEth_approveSafely_spec_eq :
    ERC20WrappedEth_approveSafely_spec =
    fun  a0 a1 a2 me => runStateT (synth_func_spec_opt ERC20WrappedEth_approveSafely ERC20WrappedEth_approveSafely_wf a0 a1 a2 me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

          ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
    reflexivity.
  Qed.

Global Opaque ERC20WrappedEth_approveSafely_opt.

  Definition ERC20WrappedEth_mint := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := nil;
    FC_returns := int_bool_pair;
    FC_body := (CCsequence
      (CCassert (CCyield (ECbinop tint_bool One
        (@ECbuiltin0 _ _  _ builtin0_caller_impl)
        (@ECbuiltin0 _ _  _ builtin0_address_impl))))
      (CCsequence
        (CCassert (CCyield (ECbinop tint_bool Ogt
          (@ECbuiltin0 _ _  _ builtin0_callvalue_impl)
          (ECconst_int256 tint_Z32 0 (Int256.repr 0)))))
        (CClet (* wrapped_amount := *) 14%positive
          (CCload (LChash tint_Z32
            (LCvar ERC20WrappedEth_wrapped_var)
            (@ECbuiltin0 _ _  _ builtin0_caller_impl)))
          (CCsequence
            (CCstore
              (LChash tint_Z32
                (LCvar ERC20WrappedEth_wrapped_var)
                (@ECbuiltin0 _ _  _ builtin0_caller_impl))
              (ECbinop tint_Z32 Oadd
                (ECtempvar tint_Z32 14%positive (* wrapped_amount *))
                (@ECbuiltin0 _ _  _ builtin0_callvalue_impl)))
            (CClet (* prev_totalSupply := *) 15%positive
              (CCload (LCvar ERC20WrappedEth__totalSupply_var))
              (CCsequence
                (CCstore
                  (LCvar ERC20WrappedEth__totalSupply_var)
                  (ECbinop tint_Z32 Oadd
                    (ECtempvar tint_Z32 15%positive (* prev_totalSupply *))
                    (@ECbuiltin0 _ _  _ builtin0_callvalue_impl)))
                (CCsequence
                  CCskip
                  (CCyield (ECconst_int256 tint_bool true Int256.one)))))))))
  |}.
  Lemma ERC20WrappedEth_mint_wf
      : synth_func_wellformed ERC20WrappedEth_mint.
  Proof. solve_wellformed. Defined.
  Definition ERC20WrappedEth_mint_opt : machine_env GetHighData -> DS bool  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
  in synth_func_spec_opt ERC20WrappedEth_mint ERC20WrappedEth_mint_wf.
  Definition ERC20WrappedEth_mint_spec_hlist_opt args :=
    @apply_param_func ERC20WrappedEth_mint.(FC_params) _
                      (ERC20WrappedEth_mint_opt) args.

(* CEI stands for Checks Effects Interactions (pattern) and the definitions below are used
    to keep track of the safe situations in which a primitive can be called. See also
    CEIP_prf in Syntax.v and for the tactic definitions see Runtime.v *)
    
Lemma ERC20WrappedEth_mint_follows_CEIP : { rsts | CEIP_function_prf (fst rsts) ERC20WrappedEth_mint (snd rsts)}.
Proof.
  unfold ERC20WrappedEth_mint.
  verify_checks_effects_interactions_pattern. (* If this tactic fails then it indicates that a strict version of the Checks-Effects-Interactions pattern was not followed in the function: ERC20WrappedEth_mint. *)
Defined.

Definition ERC20WrappedEth_mint_CEIP_color_before := fst (proj1_sig ERC20WrappedEth_mint_follows_CEIP).
Definition ERC20WrappedEth_mint_CEIP_color_after := snd (proj1_sig ERC20WrappedEth_mint_follows_CEIP).

  Definition ERC20WrappedEth_mint_prim := {|
    PRIMident := ident_ERC20WrappedEth_mint;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := ERC20WrappedEth_mint.(FC_params);
    PRIMret_marker := ERC20WrappedEth_mint.(FC_returns);
    PRIMceip_color_before := ERC20WrappedEth_mint_CEIP_color_before;
    PRIMceip_color_after := ERC20WrappedEth_mint_CEIP_color_after;
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := ERC20WrappedEth_mint_spec_hlist; *)
    PRIMsem_opt := ERC20WrappedEth_mint_spec_hlist_opt
  |}.

  Lemma ERC20WrappedEth_mint_spec_hlist_opt_eq :
    ERC20WrappedEth_mint_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt ERC20WrappedEth_mint ERC20WrappedEth_mint_wf)
      args.
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]. 
     reflexivity.
  Qed.
  Definition ERC20WrappedEth_mint_cfun :=
  Eval cbv in synth_func_func ERC20WrappedEth_mint.

  Definition ERC20WrappedEth_mint_cond  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_mint ERC20WrappedEth_mint_wf
								      me d.
  
  Lemma ERC20WrappedEth_mint_cond_eq : forall  me d, 
    ERC20WrappedEth_mint_cond  me d ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_mint ERC20WrappedEth_mint_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_mint_obligation  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_mint ERC20WrappedEth_mint_wf
								      me d.
  
  Lemma ERC20WrappedEth_mint_obligation_eq : forall  me d, 
    ERC20WrappedEth_mint_obligation  me d ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_mint ERC20WrappedEth_mint_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_mint_spec :=
  Eval cbv [sf_mem sf_return fst snd ERC20WrappedEth_mint_opt] in
    fun  me => runStateT (ERC20WrappedEth_mint_opt me).
  Lemma ERC20WrappedEth_mint_spec_eq :
    ERC20WrappedEth_mint_spec =
    fun  me => runStateT (synth_func_spec_opt ERC20WrappedEth_mint ERC20WrappedEth_mint_wf me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

          ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
    reflexivity.
  Qed.

Global Opaque ERC20WrappedEth_mint_opt.

  Definition ERC20WrappedEth_burn := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := (cons (* _value : *) int_Z32_pair nil);
    FC_returns := int_bool_pair;
    FC_body := (CCsequence
      (CCassert (CCyield (ECbinop tint_bool Oge
        (ECtempvar tint_Z32 11%positive (* _value *))
        (ECconst_int256 tint_Z32 0 (Int256.repr 0)))))
      (CCsequence
        (CCassert (CCyield (ECbinop tint_bool One
          (@ECbuiltin0 _ _  _ builtin0_caller_impl)
          (@ECbuiltin0 _ _  _ builtin0_address_impl))))
        (CCsequence
          (CCassert (CCyield (ECbinop tint_bool Oeq
            (@ECbuiltin0 _ _  _ builtin0_callvalue_impl)
            (ECconst_int256 tint_Z32 0 (Int256.repr 0)))))
          (CClet (* wrapped_amount := *) 15%positive
            (CCload (LChash tint_Z32
              (LCvar ERC20WrappedEth_wrapped_var)
              (@ECbuiltin0 _ _  _ builtin0_caller_impl)))
            (CCsequence
              (CCassert (CCyield (ECbinop tint_bool Oge
                (ECtempvar tint_Z32 15%positive (* wrapped_amount *))
                (ECtempvar tint_Z32 11%positive (* _value *)))))
              (CCsequence
                (CCstore
                  (LChash tint_Z32
                    (LCvar ERC20WrappedEth_wrapped_var)
                    (@ECbuiltin0 _ _  _ builtin0_caller_impl))
                  (ECbinop tint_Z32 Osub
                    (ECtempvar tint_Z32 15%positive (* wrapped_amount *))
                    (ECtempvar tint_Z32 11%positive (* _value *))))
                (CClet (* prev_totalSupply := *) 17%positive
                  (CCload (LCvar ERC20WrappedEth__totalSupply_var))
                  (CCsequence
                    (CCstore
                      (LCvar ERC20WrappedEth__totalSupply_var)
                      (ECbinop tint_Z32 Osub
                        (ECtempvar tint_Z32 17%positive (* prev_totalSupply *))
                        (ECtempvar tint_Z32 11%positive (* _value *))))
                    (CCsequence
                      (CCtransfer (@ECbuiltin0 _ _  _ builtin0_caller_impl)(ECtempvar tint_Z32 11%positive (* _value *)))
                      (CCsequence
                        CCskip
                        (CCyield (ECconst_int256 tint_bool true Int256.one))))))))))))
  |}.
  Lemma ERC20WrappedEth_burn_wf
      : synth_func_wellformed ERC20WrappedEth_burn.
  Proof. solve_wellformed. Defined.
  Definition ERC20WrappedEth_burn_opt :Z32 ->  machine_env GetHighData -> DS bool  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
  in synth_func_spec_opt ERC20WrappedEth_burn ERC20WrappedEth_burn_wf.
  Definition ERC20WrappedEth_burn_spec_hlist_opt args :=
    @apply_param_func ERC20WrappedEth_burn.(FC_params) _
                      (ERC20WrappedEth_burn_opt) args.

(* CEI stands for Checks Effects Interactions (pattern) and the definitions below are used
    to keep track of the safe situations in which a primitive can be called. See also
    CEIP_prf in Syntax.v and for the tactic definitions see Runtime.v *)
    
Lemma ERC20WrappedEth_burn_follows_CEIP : { rsts | CEIP_function_prf (fst rsts) ERC20WrappedEth_burn (snd rsts)}.
Proof.
  unfold ERC20WrappedEth_burn.
  verify_checks_effects_interactions_pattern. (* If this tactic fails then it indicates that a strict version of the Checks-Effects-Interactions pattern was not followed in the function: ERC20WrappedEth_burn. *)
Defined.

Definition ERC20WrappedEth_burn_CEIP_color_before := fst (proj1_sig ERC20WrappedEth_burn_follows_CEIP).
Definition ERC20WrappedEth_burn_CEIP_color_after := snd (proj1_sig ERC20WrappedEth_burn_follows_CEIP).

  Definition ERC20WrappedEth_burn_prim := {|
    PRIMident := ident_ERC20WrappedEth_burn;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := ERC20WrappedEth_burn.(FC_params);
    PRIMret_marker := ERC20WrappedEth_burn.(FC_returns);
    PRIMceip_color_before := ERC20WrappedEth_burn_CEIP_color_before;
    PRIMceip_color_after := ERC20WrappedEth_burn_CEIP_color_after;
    PRIMcond := fun _ _ _ => True;
    (* PRIMsem := ERC20WrappedEth_burn_spec_hlist; *)
    PRIMsem_opt := ERC20WrappedEth_burn_spec_hlist_opt
  |}.

  Lemma ERC20WrappedEth_burn_spec_hlist_opt_eq :
    ERC20WrappedEth_burn_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt ERC20WrappedEth_burn ERC20WrappedEth_burn_wf)
      args.
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]. 
     reflexivity.
  Qed.
  Definition ERC20WrappedEth_burn_cfun :=
  Eval cbv in synth_func_func ERC20WrappedEth_burn.

  Definition ERC20WrappedEth_burn_cond  a0 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_burn ERC20WrappedEth_burn_wf
								      a0 me d.
  
  Lemma ERC20WrappedEth_burn_cond_eq : forall  a0 me d, 
    ERC20WrappedEth_burn_cond  a0 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    high_level_invariant d ->
    synth_func_cond ERC20WrappedEth_burn ERC20WrappedEth_burn_wf  a0 me d.
    Proof.
      intros  a0 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_burn_obligation  a0 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_burn ERC20WrappedEth_burn_wf
								      a0 me d.
  
  Lemma ERC20WrappedEth_burn_obligation_eq : forall  a0 me d, 
    ERC20WrappedEth_burn_obligation  a0 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    high_level_invariant d ->
    synth_func_obligation ERC20WrappedEth_burn ERC20WrappedEth_burn_wf  a0 me d.
    Proof.
      intros  a0 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

             ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
       exact H_cond.
    Qed.

  Definition ERC20WrappedEth_burn_spec :=
  Eval cbv [sf_mem sf_return fst snd ERC20WrappedEth_burn_opt] in
    fun  a0 me => runStateT (ERC20WrappedEth_burn_opt a0 me).
  Lemma ERC20WrappedEth_burn_spec_eq :
    ERC20WrappedEth_burn_spec =
    fun  a0 me => runStateT (synth_func_spec_opt ERC20WrappedEth_burn ERC20WrappedEth_burn_wf a0 me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Z.of_nat
Int256.repr Int256.zero Int256.one Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Int256.eq Int256.lt Int256.ltu Ziteri 
List.length is_true bool_dec
negb andb orb
hashvalue_eqb me_address me_origin me_caller me_callvalue me_coinbase me_timestamp me_number me_balance me_blockhash me_transfer me_callmethod
DS Monad_DS MonadState_DS MonadZero_DS ret bind mzero get put gets guard modify runStateT OptionMonad.Monad_option
GlobalLayerSpec GetHighData  ZMap.get ZMap.set Int256Tree.t Int256Tree.get Int256Tree.set Int256Tree.empty  Int256Tree.get_default 

          ERC20WrappedEth_wrapped update_ERC20WrappedEth_wrapped ERC20WrappedEth_allowances update_ERC20WrappedEth_allowances ERC20WrappedEth__totalSupply update_ERC20WrappedEth__totalSupply].
    reflexivity.
  Qed.

Global Opaque ERC20WrappedEth_burn_opt.
End OBJECT_ERC20WrappedEth_DEFINITION.

End EdsgerGen.
